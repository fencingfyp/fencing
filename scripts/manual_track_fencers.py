"""
Input: A csv generated by process_video.py
Output: A video showing all detected people's chest point (calculated as the centre of their left shoulder and right shoulder)
"""

#!/usr/bin/env python3
import argparse
import csv
from typing import Any

import cv2

from model.FrameInfoManager import FrameInfoManager
from model.OpenCvUi import OpenCvUi, UiCodes
from scripts.estimate_poses import get_header_row

# --- CONFIG ---
BOX_COLOR = (255, 255, 255)  # White
TEXT_COLOR = (0, 0, 0)  # Black
NUM_FRAMES_TO_SKIP = 10
PLAYBACK_SPEEDUP = 64  # How much to speed up playback when not paused

NUM_KEYPOINTS = 17


def appears_in_future_detections(
    frame_manager: FrameInfoManager, current_frame_index: int, fencer_id: int
) -> bool:
    for fi in frame_manager.iter_from_frame(current_frame_index):
        if fi and fencer_id in fi:
            print(f"Fencer {fencer_id} reappears")
            return True
    return False


def row_mapper(row: list[str]) -> dict[str, Any]:
    # Convert row to dict
    id = int(row[1])
    conf = float(row[2])
    box = list(map(float, row[3:7]))
    keypoints = []
    kp_vals = row[7:]

    for i in range(NUM_KEYPOINTS):
        x = float(kp_vals[i * 3 + 0])
        y = float(kp_vals[i * 3 + 1])
        v = float(kp_vals[i * 3 + 2])
        keypoints.append((x, y, v))

    return {
        "id": id,
        "confidence": conf,
        "box": box,  # [x1, y1, x2, y2]
        "keypoints": keypoints,
    }


def obtain_fencer_ids(csv_path: str, video_path: str) -> None:
    cap: cv2.VideoCapture = cv2.VideoCapture(video_path)
    ui: OpenCvUi = OpenCvUi(
        "Obtain Fencer IDs",
        width=int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),
        height=int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)),
    )
    early_exit = False

    # Variables to track fencer IDs
    current_left_fencer_id: int | None = None
    current_right_fencer_id: int | None = None
    left_fencer_ids: set[int] = set()
    right_fencer_ids: set[int] = set()
    not_left_fencer_ids = set()
    not_right_fencer_ids = set()

    # Timers to avoid selecting fencers too frequently
    internal_clock = 0
    left_fencer_selection_timer = 0
    right_fencer_selection_timer = 0

    fps = cap.get(cv2.CAP_PROP_FPS)
    ms_per_frame = int(1000 / fps)
    delay = max(ms_per_frame // PLAYBACK_SPEEDUP, 1)
    header_format = get_header_row()
    frame_manager = FrameInfoManager(csv_path, fps, header_format, row_mapper)

    frame_idx = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        detections = frame_manager.get_frame_info_at(frame_idx)
        frame_idx += 1
        ui.set_fresh_frame(frame)
        ui.show_candidates(detections)

        if (
            current_left_fencer_id not in detections
            and not appears_in_future_detections(
                frame_manager, frame_idx, current_left_fencer_id
            )
        ):
            current_left_fencer_id = None  # lost track of left fencer
        if (
            current_right_fencer_id not in detections
            and not appears_in_future_detections(
                frame_manager, frame_idx, current_right_fencer_id
            )
        ):
            current_right_fencer_id = None  # lost track of right fencer

        # select left fencer if not selected and timer passed
        if (
            current_left_fencer_id is None
            and left_fencer_selection_timer < internal_clock
        ):
            current_left_fencer_id = get_fencer_id(
                ui, detections, left_fencer_ids, not_left_fencer_ids, left=True
            )
            if current_left_fencer_id is None:
                print("Left fencer not seen, continuing.")
                left_fencer_selection_timer = (
                    internal_clock + NUM_FRAMES_TO_SKIP * ms_per_frame
                )
            elif current_left_fencer_id == -1:
                print("Quitting.")
                early_exit = True
                break
            else:
                left_fencer_ids.add(current_left_fencer_id)
                not_right_fencer_ids.add(current_left_fencer_id)

        # select right fencer if not selected and timer passed
        if (
            current_right_fencer_id is None
            and right_fencer_selection_timer < internal_clock
        ):
            current_right_fencer_id = get_fencer_id(
                ui, detections, right_fencer_ids, not_right_fencer_ids, left=False
            )
            if current_right_fencer_id is None:
                print("Right fencer not seen, continuing.")
                right_fencer_selection_timer = (
                    internal_clock + NUM_FRAMES_TO_SKIP * ms_per_frame
                )
            elif current_right_fencer_id == -1:
                print("Quitting.")
                early_exit = True
                break
            else:
                right_fencer_ids.add(current_right_fencer_id)
                not_left_fencer_ids.add(current_right_fencer_id)

        internal_clock += ms_per_frame
        action = ui.take_user_input(delay, [UiCodes.QUIT])
        if action == UiCodes.QUIT:
            break

    cap.release()
    ui.close()
    return left_fencer_ids, right_fencer_ids, early_exit


def get_fencer_id(
    ui: OpenCvUi,
    detections: dict[int, dict],
    known_ids: set[int],
    exclude_ids: set[int],
    left: bool,
) -> int | None:
    if len(detections) == 0:
        return None
    candidates = {
        det_id: det for det_id, det in detections.items() if det_id not in exclude_ids
    }
    if not candidates:
        return None
    for candidate in candidates.values():
        if candidate["id"] in known_ids:
            return candidate["id"]  # if one candidate is already known, return them

    return ui.get_fencer_id(candidates, left)


def reprocess_csv(
    input_csv: str,
    left_fencer_ids: set[int],
    right_fencer_ids: set[int],
    output_csv_path: str,
) -> None:
    with open(output_csv_path, "w") as output_csv:
        with open(input_csv, "r") as input_csv:
            # skip header
            next(input_csv)
            # Process each frame's detections and write to the output CSV
            while input_csv:
                line = input_csv.readline()
                if not line:
                    break
                id = int(line.strip().split(",")[1])  # get id
                if id in left_fencer_ids:
                    fencer_dir = 0  # Left
                elif id in right_fencer_ids:
                    fencer_dir = 1  # Right
                else:
                    continue  # Skip if fencer ID is not recognized
                parts = line.strip().split(",")
                # Replace the fencer ID with 0 for left and 1 for right
                parts[1] = str(fencer_dir)
                line = ",".join(parts) + "\n"
                output_csv.write(line)


def main():
    parser = argparse.ArgumentParser(description="Process CSV with video input")
    parser.add_argument("video_path", help="Path to input.mp4")
    parser.add_argument("csv_path", help="Path to results.csv")
    parser.add_argument(
        "--output",
        type=str,
        default=None,
        help="Output csv file path (default: same as input csv folder, with _with_ids suffix)",
    )
    args = parser.parse_args()

    csv_path = args.csv_path
    video_path = args.video_path
    output_path = args.output
    left_fencer_ids, right_fencer_ids, early_exit = obtain_fencer_ids(
        csv_path, video_path
    )
    if early_exit:
        print("Exiting early, not outputting csv.")
        return

    if output_path is None:
        output_path = csv_path.rsplit(".", 1)[0] + "_with_ids.csv"

    reprocess_csv(csv_path, left_fencer_ids, right_fencer_ids, output_path)


if __name__ == "__main__":
    main()

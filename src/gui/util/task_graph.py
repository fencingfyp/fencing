"""
TaskGraph DAG Model
Generated by ChatGPT
==================

Lightweight dependency model for task pipelines where each task produces output files.

Principles
----------
- The DAG is the source of truth for task state.
- The filesystem is only checked for a task's own outputs.
- Dependency validity is handled by in-memory propagation (no recursive rescans).
- Assumes users do not manually modify the working directory.

States
------
LOCKED       : Dependencies not satisfied.
READY        : Can run (deps done, outputs missing).
DONE         : Outputs exist and deps satisfied.

Usage
-----
- Create Task(id, outputs, deps)
- Build graph = TaskGraph(tasks)
- On task finish: graph.mark_finished(id)
- On rerun:      graph.rerun(id)

Signals
-------
- task_changed(task_id)
- graph_changed()

Notes
-----
- Cycles are not supported.
- Add full rescans or timestamps if external file edits must be handled.
"""

from collections import defaultdict
from dataclasses import dataclass
from enum import Enum
from pathlib import Path

from PySide6.QtCore import QObject, Signal

from src.pyside.MatchContext import MatchContext


class MomentumGraphTasksToIds(Enum):
    CROP_REGIONS = "Identify Scoreboard, Timer and Piste"
    PERFORM_OCR = "Extract Scoring"
    DETECT_SCORE_LIGHTS = "Detect Score Lights"
    GENERATE_MOMENTUM_GRAPH = "Generate Momentum Graph"
    SELECT_PERIODS = "Select Periods"
    VIEW_STATS = "View Stats"


class HeatMapTasksToIds(Enum):
    TRACK_POSES = "track_poses"
    TRACK_FENCERS = "track_fencers"
    GENERATE_HEAT_MAP = "generate_heat_map"
    CROP_REGIONS = "Identify Scoreboard, Timer and Piste"
    PERFORM_OCR = "Extract Scoring"
    DETECT_SCORE_LIGHTS = "Detect Score Lights"
    GENERATE_MOMENTUM_GRAPH = "Generate Momentum Graph"


class TaskState(Enum):
    LOCKED = 0
    READY = 1
    DONE = 2


@dataclass
class GraphNode:
    id: str
    state: TaskState
    deps: list[str]
    children: list[str]


@dataclass
class GraphLayout:
    layers: list[list[str]]  # left → right columns
    edges: list[tuple[str, str]]  # (from, to)


class Task:
    def __init__(self, tid: str, outputs: list[str], deps: list[str] | None = None):
        self.id = tid
        self.outputs = [Path(p) for p in outputs]
        self.deps = deps or []
        self.children: list[str] = []
        self.state = TaskState.LOCKED


class TaskGraph(QObject):
    task_changed = Signal(str)
    graph_changed = Signal()

    def __init__(
        self,
        tasks: list[Task],
        match_context: MatchContext,
        parent=None,
    ):
        super().__init__(parent)

        self.tasks: dict[str, Task] = {t.id: t for t in tasks}
        self.match_context = match_context

        # build children adjacency
        for t in tasks:
            for dep in t.deps:
                self.tasks[dep].children.append(t.id)

        self.match_context.match_changed.connect(self._on_match_changed)

    # ---------- public API ----------

    def state(self, tid: str) -> TaskState:
        return self.tasks[tid].state

    def rerun(self, tid: str):
        """User reruns a task → invalidate all downstream."""
        self._invalidate_downstream(tid)
        self.tasks[tid].state = TaskState.READY
        self._recompute_children(tid)
        self.graph_changed.emit()

    def mark_finished(self, tid: str):
        """Call when a task finishes running."""
        self._update_single_task(tid)
        self._recompute_children(tid)
        self.graph_changed.emit()

    def set_working_directory(self, working_dir: str):
        """Set or change the working directory and rescan all tasks."""
        self.working_dir = Path(working_dir)
        self._initial_scan()
        self.graph_changed.emit()

    def get_task_states(self) -> dict[str, str]:
        """Get mapping of task ID → state name."""
        return {tid: task.state.name for tid, task in self.tasks.items()}

    def get_index_map(self) -> dict[str, int]:
        """Get mapping of task ID → topological index (1-based)."""
        topo_order = self.topological_order()
        return {tid: i + 1 for i, tid in enumerate(topo_order)}  # 1-based

    # ---------- core logic ----------

    def _on_match_changed(self):
        self._initial_scan()
        self.graph_changed.emit()

    def _initial_scan(self):
        """Initial pass: check only each node + direct deps."""
        for tid in self.tasks:
            self._update_single_task(tid)

        # unlock layers in topological order-ish
        for tid in self.tasks:
            self._recompute_children(tid)

    def _outputs_exist(self, task: Task) -> bool:
        return all(self.match_context.file_manager.file_exists(p) for p in task.outputs)

    def _deps_done(self, task: Task) -> bool:
        return all(self.tasks[d].state == TaskState.DONE for d in task.deps)

    def _update_single_task(self, tid: str):
        task = self.tasks[tid]

        if not self._deps_done(task):
            task.state = TaskState.LOCKED
            return

        if self._outputs_exist(task):
            task.state = TaskState.DONE
        else:
            task.state = TaskState.READY

        self.task_changed.emit(tid)

    def _recompute_children(self, tid: str):
        """Re-evaluate only direct children — propagation handles the rest."""
        for child_id in self.tasks[tid].children:
            child = self.tasks[child_id]

            old = child.state
            self._update_single_task(child_id)

            # if this changed, propagate further
            if child.state != old:
                self._recompute_children(child_id)

    def _invalidate_downstream(self, tid: str):
        for child_id in self.tasks[tid].children:
            child = self.tasks[child_id]
            if child.state in (TaskState.DONE, TaskState.READY):
                child.state = TaskState.LOCKED
                self.task_changed.emit(child_id)
                self._invalidate_downstream(child_id)

    def snapshot(self) -> GraphLayout:
        layers = self._topological_layers()
        edges = [(t.id, c) for t in self.tasks.values() for c in t.children]
        return GraphLayout(layers, edges)

    def _topological_layers(self) -> list[list[str]]:
        depth: dict[str, int] = {}

        def compute_depth(tid: str) -> int:
            if tid in depth:
                return depth[tid]
            if not self.tasks[tid].deps:
                depth[tid] = 0
            else:
                depth[tid] = 1 + max(compute_depth(d) for d in self.tasks[tid].deps)
            return depth[tid]

        for tid in self.tasks:
            compute_depth(tid)

        layers: dict[int, list[str]] = defaultdict(list)
        for tid, d in depth.items():
            layers[d].append(tid)

        return [layers[i] for i in sorted(layers)]

    def topological_order(self) -> list[str]:
        visited = set()
        order = []

        def dfs(tid: str):
            if tid in visited:
                return
            visited.add(tid)
            for child in self.tasks[tid].children:
                dfs(child)
            order.append(tid)

        for tid in self.tasks:
            dfs(tid)

        return list(reversed(order))

"""
TaskGraph DAG Model
Generated by ChatGPT
==================

Lightweight dependency model for task pipelines where each task produces output files.

Principles
----------
- The DAG is the source of truth for task state.
- The filesystem is only checked for a task's own outputs.
- Dependency validity is handled by in-memory propagation (no recursive rescans).
- Assumes users do not manually modify the working directory.

States
------
LOCKED       : Dependencies not satisfied.
READY        : Can run (deps done, outputs missing).
DONE         : Outputs exist and deps satisfied.

Usage
-----
- Create Task(id, outputs, deps)
- Build graph = TaskGraph(tasks)
- On task finish: graph.mark_finished(id)
- On rerun:      graph.rerun(id)

Signals
-------
- task_changed(task_id)
- graph_changed()

Notes
-----
- Cycles are not supported.
- Add full rescans or timestamps if external file edits must be handled.
"""

from collections import defaultdict
from enum import Enum
from pathlib import Path

from PySide6.QtCore import QObject, Signal


class MomentumGraphTasksToIds(Enum):
    CROP_SCOREBOARD = "crop_scoreboard"
    CROP_SCORE_LIGHTS = "crop_score_lights"
    PERFORM_OCR = "perform_ocr"
    DETECT_SCORE_LIGHTS = "detect_score_lights"
    GENERATE_MOMENTUM_GRAPH = "generate_momentum_graph"


class TaskState(Enum):
    LOCKED = 0
    READY = 1
    DONE = 2


class Task:
    def __init__(self, tid: str, outputs: list[str], deps: list[str] | None = None):
        self.id = tid
        self.outputs = [Path(p) for p in outputs]
        self.deps = deps or []
        self.children: list[str] = []
        self.state = TaskState.LOCKED


class TaskGraph(QObject):
    task_changed = Signal(str)
    graph_changed = Signal()

    def __init__(self, tasks: list[Task], working_dir: str | None = None):
        super().__init__()

        self.tasks: dict[str, Task] = {t.id: t for t in tasks}
        self.working_dir = Path(working_dir) if working_dir else None

        # build children adjacency
        for t in tasks:
            for dep in t.deps:
                self.tasks[dep].children.append(t.id)

        # initial evaluation from filesystem
        self._initial_scan()

    # ---------- public API ----------

    def state(self, tid: str) -> TaskState:
        return self.tasks[tid].state

    def rerun(self, tid: str):
        """User reruns a task → invalidate all downstream."""
        self._invalidate_downstream(tid)
        self.tasks[tid].state = TaskState.READY
        self._recompute_children(tid)
        self.graph_changed.emit()

    def mark_finished(self, tid: str):
        """Call when a task finishes running."""
        self._update_single_task(tid)
        self._recompute_children(tid)
        self.graph_changed.emit()

    def set_working_directory(self, working_dir: str):
        """Set or change the working directory and rescan all tasks."""
        self.working_dir = Path(working_dir)
        self._initial_scan()
        self.graph_changed.emit()

    # ---------- core logic ----------

    def _initial_scan(self):
        """Initial pass: check only each node + direct deps."""
        for tid in self.tasks:
            self._update_single_task(tid)

        # unlock layers in topological order-ish
        for tid in self.tasks:
            self._recompute_children(tid)

    def _outputs_exist(self, task: Task) -> bool:
        if self.working_dir is None:
            return all(p.exists() for p in task.outputs)
        return all((self.working_dir / p).exists() for p in task.outputs)

    def _deps_done(self, task: Task) -> bool:
        return all(self.tasks[d].state == TaskState.DONE for d in task.deps)

    def _update_single_task(self, tid: str):
        task = self.tasks[tid]

        if not self._deps_done(task):
            task.state = TaskState.LOCKED
            return

        if self._outputs_exist(task):
            task.state = TaskState.DONE
        else:
            task.state = TaskState.READY

        self.task_changed.emit(tid)

    def _recompute_children(self, tid: str):
        """Re-evaluate only direct children — propagation handles the rest."""
        for child_id in self.tasks[tid].children:
            child = self.tasks[child_id]

            old = child.state
            self._update_single_task(child_id)

            # if this changed, propagate further
            if child.state != old:
                self._recompute_children(child_id)

    def _invalidate_downstream(self, tid: str):
        for child_id in self.tasks[tid].children:
            child = self.tasks[child_id]
            if child.state in (TaskState.DONE, TaskState.READY):
                child.state = TaskState.LOCKED
                self.task_changed.emit(child_id)
                self._invalidate_downstream(child_id)
